<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Lo siento mucho</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="styles.css" rel="stylesheet" />
  <meta name="description" content="Un espacio sincero para pedir perdón y comprometer cambios reales." />
</head>
<body>
  <main class="container" id="app">
    <section class="hero" aria-labelledby="h1">
      <h1 id="h1" class="sr-only">Lo siento mucho</h1>
      <div id="heroLine" class="typewriter" aria-live="polite"></div>
      <p id="heroSub" class="hero-sub"></p>
      <span class="heart"></span>
    </section>

    <section class="cards" id="cards" aria-label="Razones y compromisos"></section>

    <section class="commitments" id="commitmentsSection" aria-labelledby="commitTitle">
      <h2 id="commitTitle">Mis compromisos</h2>
      <div id="ckList" class="ck-list"></div>
      <div class="progress">
        <progress id="prog" max="0" value="0" aria-label="Progreso compromisos"></progress>
        <span id="progText">0/0</span>
      </div>
      <button id="cta" class="cta" type="button"></button>
    </section>
  </main>

  <script>
    // ========================
    // CONFIGURACIÓN EDITABLE
    // Modifica SOLO este objeto para cambiar todo el texto.
    // ========================
    const CONFIG = {
      heroLine: "¿Podrías darme otra oportunidad?",
      heroSub: "Desde lo más sincero de mi corazón, y aceptando todas las condiciones y límites que me impongas, quiero reparar cada error que he cometido con hechos, no con palabras.",
      cards: [
        { front: "Tus condiciones primero", back: "Acepto límites, pruebas y tiempos como tu lo veas conveniente para tomar una decision, sin excepciones." },
        { front: "Transparencia total", back: "Verdad completa y a tiempo, nada quedará oculto o silenciado, todo estará siempre claro para evitar conflictos." },
        { front: "Escuchar y calma", back: "Pausar, pensar, no habrá lugar para rabia, enojos o conclusiones apuradas." },
        { front: "Fe y familia", back: "Recordar y honrar lo aprendido: corregir a tiempo y caminar en lo correcto, juntos." }
      ],
      commitments: [
        "Cumplir cada condición que establezcas, sin excusas ni atajos.",
        "Ser transparente en todo momento, sin excepciones.",
        "Escuchar de verdad, bajar la intensidad y hablar con calma.",
        "Buscar tu ayuda y tu opinión para no repetir errores.",
        "Respetar tus tiempos y tu espacio; puedes decidir en cuanto lo veas viable.",
        "Usar cada día y la fuerza que Dios me da para demostrarte cambios realistas y sinceros."
      ],
      ctaText: "Espero que puedas comprender todo lo que te expreso, he usado todo lo aprendido para expresarte mis sentimientos :'(",
      ctaAlert: "Gracias por tomarte el tiempo de revisarlo. ¿Podrias considerar mi propuesta? :'(",
      typingDurationMs: 3400
    };

    // ========================
    // UTILIDADES DOM (DRY)
    // ========================
    const DOM = {
      qs: (sel, el = document) => el.querySelector(sel),
      qsa: (sel, el = document) => Array.from(el.querySelectorAll(sel)),
      createElement: (tag, className = '', content = '') => {
        const el = document.createElement(tag);
        if (className) el.className = className;
        if (content) el.textContent = content;
        return el;
      }
    };

    // ========================
    // RENDERIZADOR HERO (SRP)
    // ========================
    class HeroRenderer {
      static render(config) {
        const heroLine = DOM.qs('#heroLine');
        const heroSub = DOM.qs('#heroSub');
        const heart = DOM.qs('.heart');
        
        heroLine.textContent = config.heroLine;
        heroLine.style.setProperty('--steps', String(config.heroLine.length || 30));
        heroLine.style.setProperty('--typing-duration', `${config.typingDurationMs || 3000}ms`);
        heroSub.textContent = config.heroSub;
        
        // Configurar corazón interactivo
        this.setupHeartInteraction(heart);
      }

      static setupHeartInteraction(heartElement) {
        // Hacer el corazón clickeable
        heartElement.style.cursor = 'pointer';
        heartElement.setAttribute('role', 'button');
        heartElement.setAttribute('tabindex', '0');
        heartElement.setAttribute('aria-label', 'Toca para ver una sorpresa');
        
        // Evento de click (funciona para desktop y tap corto en móviles)
        heartElement.addEventListener('click', (e) => {
          // CRÍTICO: Limpiar tooltip antes de cualquier acción
          TooltipManager.hideTooltip();
          
          // En móviles, solo ejecutar si no fue un long press
          if (TooltipManager.isTouchDevice) {
            // Verificar si el tooltip estaba activo (indica long press)
            if (TooltipManager.activeTooltip) {
              e.preventDefault();
              return;
            }
          }
          
          // Pequeño delay para asegurar que el tooltip se haya limpiado
          setTimeout(() => {
            VideoManager.showVideo();
          }, 50);
        });
        
        // Evento de teclado
        heartElement.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            TooltipManager.hideTooltip();
            VideoManager.showVideo();
          }
        });
        
        // Tooltip con lógica inteligente
        TooltipManager.bindTooltipEvents(heartElement, 'Toca para ver una sorpresa ❤️');
      }
    }

    // ========================
    // RENDERIZADOR CARDS (SRP)
    // ========================
    class CardRenderer {
      static createCard({ front, back }, index) {
        const card = DOM.createElement('div', 'card');
        card.tabIndex = 0;
        card.setAttribute('aria-label', `${front}. Click para ver más información`);
        card.setAttribute('role', 'button');
        
        card.innerHTML = `
          <div class="card-content">
            <h3>${front}</h3>
            <div class="card-hint">Toca para ver más</div>
          </div>
        `;
        
        // Evento de click/touch
        card.addEventListener('click', () => {
          ModalManager.show(front, back);
        });
        
        // Evento de teclado para accesibilidad
        card.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            card.click();
          }
        });
        
        return card;
      }

      static render(cards) {
        const container = DOM.qs('#cards');
        container.innerHTML = '';
        cards.forEach((card, index) => container.appendChild(this.createCard(card, index)));
      }
    }

    // ========================
    // RENDERIZADOR COMPROMISOS (SRP)
    // ========================
    class CommitmentsRenderer {
      static createCommitmentItem(text, index) {
        const id = `c_${index + 1}`;
        const label = DOM.createElement('label', 'ck-item');
        
        label.innerHTML = `
          <input type="checkbox" id="${id}" data-key="${id}" />
          <span>${text}</span>
        `;
        
        return label;
      }

      static render(commitments, ctaText, ctaAlert) {
        const list = DOM.qs('#ckList');
        const progress = DOM.qs('#prog');
        const progressText = DOM.qs('#progText');
        const ctaButton = DOM.qs('#cta');
        
        // Limpiar y renderizar lista
        list.innerHTML = '';
        commitments.forEach((text, i) => {
          list.appendChild(this.createCommitmentItem(text, i));
        });
        
        // Configurar progreso
        progress.max = commitments.length;
        progressText.textContent = `0/${commitments.length}`;
        
        // Configurar CTA
        ctaButton.textContent = ctaText;
        ctaButton.addEventListener('click', () => {
          alert(ctaAlert);
          WhatsAppManager.redirectToWhatsApp();
        });
      }
    }

    // ========================
    // GESTOR DE ESTADO (SRP)
    // ========================
    class StateManager {
      static STORAGE_PREFIX = 'apology_';

      static loadState() {
        DOM.qsa('.ck-list input[type="checkbox"]').forEach(checkbox => {
          const value = localStorage.getItem(this.STORAGE_PREFIX + checkbox.dataset.key);
          if (value === '1') checkbox.checked = true;
        });
        this.updateProgress();
      }

      static updateProgress() {
        const checkboxes = DOM.qsa('.ck-list input[type="checkbox"]');
        const completed = checkboxes.filter(cb => cb.checked).length;
        
        DOM.qs('#prog').value = completed;
        DOM.qs('#progText').textContent = `${completed}/${checkboxes.length}`;
      }

      static bindCommitments() {
        DOM.qsa('.ck-list input[type="checkbox"]').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            const key = this.STORAGE_PREFIX + checkbox.dataset.key;
            localStorage.setItem(key, checkbox.checked ? '1' : '0');
            this.updateProgress();
          });
        });
      }
    }

    // ========================
    // GESTOR DE MODALES (SRP)
    // ========================
    class ModalManager {
      static createModal() {
        const modal = DOM.createElement('div', 'modal-overlay');
        modal.setAttribute('role', 'dialog');
        modal.setAttribute('aria-modal', 'true');
        modal.setAttribute('aria-hidden', 'true');
        
        modal.innerHTML = `
          <div class="modal-content">
            <div class="modal-header">
              <h2 class="modal-title"></h2>
              <button class="modal-close" aria-label="Cerrar">&times;</button>
            </div>
            <div class="modal-body">
              <p class="modal-message"></p>
            </div>
            <div class="modal-footer">
              <button class="modal-btn modal-btn-primary">Entendido</button>
            </div>
          </div>
        `;
        
        return modal;
      }

      static show(title, message) {
        // Crear modal si no existe
        let modal = DOM.qs('.modal-overlay');
        if (!modal) {
          modal = this.createModal();
          document.body.appendChild(modal);
        }
        
        // Configurar contenido
        DOM.qs('.modal-title', modal).textContent = title;
        DOM.qs('.modal-message', modal).textContent = message;
        
        // Mostrar modal
        modal.setAttribute('aria-hidden', 'false');
        modal.classList.add('active');
        document.body.classList.add('modal-open');
        
        // Enfocar el botón de cerrar
        DOM.qs('.modal-close', modal).focus();
        
        // Eventos de cierre
        this.bindCloseEvents(modal);
      }

      static hide(modal) {
        modal.setAttribute('aria-hidden', 'true');
        modal.classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      static bindCloseEvents(modal) {
        const closeBtn = DOM.qs('.modal-close', modal);
        const primaryBtn = DOM.qs('.modal-btn-primary', modal);
        const overlay = modal;
        
        const closeModal = () => this.hide(modal);
        
        closeBtn.addEventListener('click', closeModal);
        primaryBtn.addEventListener('click', closeModal);
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) closeModal();
        });
        
        // Cerrar con Escape
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
      }
    }

    // ========================
    // GESTOR DE TOOLTIP INTELIGENTE Y RESPONSIVO (SRP)
    // ========================
    class TooltipManager {
      static isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      static isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      static activeTooltip = null;
      static tooltipTimeout = null;

      static createTooltip(text, targetElement) {
        const tooltip = DOM.createElement('div', 'tooltip');
        tooltip.textContent = text;
        tooltip.setAttribute('role', 'tooltip');
        tooltip.setAttribute('aria-hidden', 'true');
        
        // Posicionamiento inteligente y responsivo
        this.positionTooltip(tooltip, targetElement);
        
        return tooltip;
      }

      static positionTooltip(tooltip, targetElement) {
        const rect = targetElement.getBoundingClientRect();
        const tooltipRect = { width: 200, height: 40 }; // Estimación inicial
        const viewport = {
          width: window.innerWidth,
          height: window.innerHeight,
          scrollX: window.pageXOffset,
          scrollY: window.pageYOffset
        };

        // Calcular posición ideal
        let top = rect.top - tooltipRect.height - 10;
        let left = rect.left + (rect.width / 2);

        // Ajustar si se sale del viewport horizontalmente
        if (left - tooltipRect.width / 2 < 10) {
          left = 10 + tooltipRect.width / 2;
        } else if (left + tooltipRect.width / 2 > viewport.width - 10) {
          left = viewport.width - 10 - tooltipRect.width / 2;
        }

        // Ajustar si se sale del viewport verticalmente
        if (top < 10) {
          top = rect.bottom + 10; // Mostrar abajo
          tooltip.classList.add('tooltip-below');
        }

        // Aplicar posición
        tooltip.style.position = 'fixed';
        tooltip.style.top = `${top}px`;
        tooltip.style.left = `${left}px`;
        tooltip.style.transform = 'translateX(-50%)';
      }

      static showTooltip(text, targetElement) {
        // CRÍTICO: No mostrar tooltip si hay modales activos
        if (this.hasActiveModals()) {
          return null;
        }
        
        this.hideTooltip(); // Limpiar tooltip existente
        
        const tooltip = this.createTooltip(text, targetElement);
        document.body.appendChild(tooltip);
        this.activeTooltip = tooltip;
        
        // Mostrar con delay adaptativo
        const delay = this.isMobile ? 200 : 100;
        setTimeout(() => {
          if (tooltip.parentNode && !this.hasActiveModals()) {
            tooltip.classList.add('active');
            tooltip.setAttribute('aria-hidden', 'false');
          }
        }, delay);
        
        return tooltip;
      }

      static hideTooltip() {
        if (this.activeTooltip) {
          this.activeTooltip.remove();
          this.activeTooltip = null;
        }
        if (this.tooltipTimeout) {
          clearTimeout(this.tooltipTimeout);
          this.tooltipTimeout = null;
        }
      }

      static hasActiveModals() {
        // Verificar si hay modales activos
        const videoModal = DOM.qs('.video-modal-overlay.active');
        const regularModal = DOM.qs('.modal-overlay.active');
        return !!(videoModal || regularModal);
      }

      static bindTooltipEvents(element, text) {
        let showTimeout;
        let hideTimeout;
        let touchStartTime;
        let isLongPress = false;
        
        // Eventos para desktop (mouse)
        if (!this.isTouchDevice) {
          element.addEventListener('mouseenter', () => {
            showTimeout = setTimeout(() => {
              this.showTooltip(text, element);
            }, 300); // Delay reducido para mejor UX
          });
          
          element.addEventListener('mouseleave', () => {
            clearTimeout(showTimeout);
            this.hideTooltip();
          });
        }
        
        // Eventos para móviles (touch) - Lógica inteligente
        if (this.isTouchDevice) {
          element.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            isLongPress = false;
            
            // Iniciar timer para long press (tooltip)
            showTimeout = setTimeout(() => {
              isLongPress = true;
              element.classList.add('long-press'); // Feedback visual
              this.showTooltip(text, element);
              
              // Ocultar tooltip después de 3 segundos
              hideTimeout = setTimeout(() => {
                this.hideTooltip();
                element.classList.remove('long-press');
              }, 3000);
            }, 500); // 500ms para considerar long press
          });
          
          element.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            
            // Si fue un tap corto (menos de 500ms), no mostrar tooltip
            if (touchDuration < 500 && !isLongPress) {
              clearTimeout(showTimeout);
              // No hacer preventDefault para permitir el click normal
              return;
            }
            
            // Si fue long press, prevenir el click
            if (isLongPress) {
              e.preventDefault();
            }
          });
          
          element.addEventListener('touchcancel', () => {
            clearTimeout(showTimeout);
            clearTimeout(hideTimeout);
            isLongPress = false;
            element.classList.remove('long-press');
          });
        }
        
        // Eventos de teclado para accesibilidad
        element.addEventListener('focus', () => {
          this.showTooltip(text, element);
        });
        
        element.addEventListener('blur', () => {
          this.hideTooltip();
        });
        
        // Ocultar tooltip al hacer scroll o redimensionar
        window.addEventListener('scroll', () => this.hideTooltip(), { passive: true });
        window.addEventListener('resize', () => this.hideTooltip(), { passive: true });
        
        // Ocultar tooltip cuando se abren modales (medida adicional de seguridad)
        document.addEventListener('click', (e) => {
          if (e.target.closest('.modal-overlay, .video-modal-overlay')) {
            this.hideTooltip();
          }
        });
      }
    }

    // ========================
    // GESTOR DE VIDEO (SRP)
    // ========================
    class VideoManager {
      static VIDEO_PATH = 'files/video.mp4';
      static VIDEO_CONFIG = {
        width: 720,
        height: 720,
        duration: 38.42,
        aspectRatio: '1:1'
      };

      static createVideoModal() {
        const modal = DOM.createElement('div', 'video-modal-overlay');
        modal.setAttribute('role', 'dialog');
        modal.setAttribute('aria-modal', 'true');
        modal.setAttribute('aria-hidden', 'true');
        modal.setAttribute('aria-label', 'Reproductor de video sorpresa');
        
        modal.innerHTML = `
          <div class="video-modal-content">
            <div class="video-modal-header">
              <h2 class="video-modal-title">Una sorpresa para ti ❤️</h2>
              <button class="video-modal-close" aria-label="Cerrar video">&times;</button>
            </div>
            <div class="video-modal-body">
              <video class="video-player" controls preload="metadata" aria-label="Video sorpresa">
                <source src="${this.VIDEO_PATH}" type="video/mp4">
                Tu navegador no soporta la reproducción de video.
              </video>
            </div>
            <div class="video-modal-footer">
              <!-- Footer vacío - solo se usa el botón X del header -->
            </div>
          </div>
        `;
        
        return modal;
      }

      static showVideo() {
        // CRÍTICO: Limpiar tooltip antes de mostrar modal
        TooltipManager.hideTooltip();
        
        let modal = DOM.qs('.video-modal-overlay');
        if (!modal) {
          modal = this.createVideoModal();
          document.body.appendChild(modal);
        }
        
        // Mostrar modal
        modal.setAttribute('aria-hidden', 'false');
        modal.classList.add('active');
        document.body.classList.add('video-modal-open');
        
        // Enfocar el botón de cerrar
        DOM.qs('.video-modal-close', modal).focus();
        
        // Eventos de cierre
        this.bindVideoCloseEvents(modal);
      }

      static hideVideo(modal) {
        const video = DOM.qs('.video-player', modal);
        if (video) {
          video.pause();
          video.currentTime = 0;
        }
        
        modal.setAttribute('aria-hidden', 'true');
        modal.classList.remove('active');
        document.body.classList.remove('video-modal-open');
      }

      static bindVideoCloseEvents(modal) {
        const closeBtn = DOM.qs('.video-modal-close', modal);
        const overlay = modal;
        
        const closeVideo = () => this.hideVideo(modal);
        
        closeBtn.addEventListener('click', closeVideo);
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) closeVideo();
        });
        
        // Cerrar con Escape
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            closeVideo();
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
      }
    }

    // ========================
    // GESTOR DE WHATSAPP (SRP)
    // ========================
    class WhatsAppManager {
      static PHONE_NUMBER = '+593993686769';
      static DEFAULT_MESSAGE = 'Hablemos';

      static generateWhatsAppURL(phoneNumber = this.PHONE_NUMBER, message = this.DEFAULT_MESSAGE) {
        const encodedMessage = encodeURIComponent(message);
        const cleanPhoneNumber = phoneNumber.replace(/[^\d+]/g, '');
        return `https://wa.me/${cleanPhoneNumber}?text=${encodedMessage}`;
      }

      static redirectToWhatsApp(phoneNumber = this.PHONE_NUMBER, message = this.DEFAULT_MESSAGE) {
        const url = this.generateWhatsAppURL(phoneNumber, message);
        window.open(url, '_blank');
      }
    }

    // ========================
    // CONTROLADOR PRINCIPAL (SRP)
    // ========================
    class AppController {
      static initialize() {
        this.setupAccessibility();
        this.render();
        this.bindEvents();
      }

      static setupAccessibility() {
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (prefersReducedMotion) {
          document.documentElement.classList.add('reduced-motion');
        }
      }

      static render() {
        HeroRenderer.render(CONFIG);
        CardRenderer.render(CONFIG.cards);
        CommitmentsRenderer.render(CONFIG.commitments, CONFIG.ctaText, CONFIG.ctaAlert);
      }

      static bindEvents() {
        StateManager.loadState();
        StateManager.bindCommitments();
      }
    }

    // ========================
    // INICIALIZACIÓN
    // ========================
    document.addEventListener('DOMContentLoaded', () => AppController.initialize());
  </script>
</body>
</html>
